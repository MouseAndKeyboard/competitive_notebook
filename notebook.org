#+TITLE: Notebook

* Computational Geometry
** Rational Number Class
*** Simplify
#+NAME: rational-simp
After simplification, if the number is negative, the numerator
will be the negative value.
#+BEGIN_SRC C++
#include <algorithm>

template<typename T, typename U>
void Rational<T,U>::simplify(void) {
    // Fixes negative denominators.
    if (this->denom < 0)
    {
        this->numer *= -1;
        this->denom *= -1;
    }

    // Simplifies Rational Numbers.
    int den = std::__gcd(this->numer, this->denom);

    this->numer /= den;
    this->denom /= den;
}
#+END_SRC

**** Test
#+NAME: test-rational-simp
#+BEGIN_SRC C++
Rational<int,int> simp1 = Rational<int,int>(10, 5);
simp1.simplify();
assert(simp1.numer == 2 && simp1.denom == 1);
Rational<int, int> simp2 = Rational<int, int>(5, 10);
simp2.simplify();
assert(simp2.numer == 1 && simp2.denom == 2);
Rational<int, int> simp3 = Rational<int, int>(7, 3);
simp3.simplify();
assert(simp3.numer == 7 && simp3.denom == 3);
Rational<int,int> simp4 = Rational<int,int>(4,-2);
simp4.simplify();
assert(simp4.numer == -2 && simp4.denom == 1);
#+END_SRC

*** Rescale denominator
Set the denominator to a new value, scale the numerator appropriately.

*WARNING:* newval should either or divide or be divided by the denominator
otherwise the numerator will be incorrectly scaled.

#+NAME: rational-rescale
#+BEGIN_SRC C++
template<typename T, typename U>
void Rational<T,U>::rescale_denom(U newval)
{
    U scalefactor;
    if (newval >= denom)
    {
        scalefactor = newval / denom;
        numer *= scalefactor;
    }
    else
    {
        scalefactor = denom / newval;
        numer /= scalefactor;
    }
    denom = newval;
    return;
}
#+END_SRC

**** Tests
#+NAME: test-rational-rescale
#+BEGIN_SRC C++
Rational<int,int> rescale_a = Rational<int,int>(4,7);
rescale_a.rescale_denom(21);
assert(rescale_a.denom == 21 && rescale_a.numer == 12);
Rational<int,int> rescale_b = Rational<int,int>(6,15);
rescale_b.rescale_denom(5);
assert(rescale_b.denom == 5 && rescale_b.numer == 2);
#+END_SRC

*** Rational add
Adds two fractions together, denominator will be the product of the
denominators of the inputs.

#+NAME: rational-add
#+BEGIN_SRC C++
template<typename T, typename U>
Rational<T,U> Rational<T,U>::operator+(Rational<T,U> const &obj)
{
    if (denom == obj.denom)
    {
        return Rational(numer + obj.numer, denom);
    }
    else {
        return Rational(numer * obj.denom + denom * obj.numer,
                        denom * obj.denom);
    }
}
#+END_SRC

**** Tests
#+NAME: test-rational-add
#+BEGIN_SRC C++
Rational<int,int> rat_add_a = Rational<int,int>(1,4);
Rational<int,int> rat_add_b = Rational<int,int>(2,4);
Rational<int,int> rat_add_r1 = rat_add_a + rat_add_b;
assert(rat_add_r1.numer == 3 && rat_add_r1.denom == 4);
Rational<int,int> rat_add_c = Rational<int,int>(5,7);
Rational<int,int> rat_add_r2 = rat_add_a + rat_add_c;
rat_add_r2.simplify();
assert(rat_add_r2.numer == 27 && rat_add_r2.denom == 28);
#+END_SRC

*** Rational subtraction
Subtracts two fractions;
\( \frac{a}{b} - \frac{c}{d} = \frac{a d - c b}{b d}\)

#+NAME: rational-sub
#+BEGIN_SRC C++
template<typename T, typename U>
Rational<T,U> Rational<T,U>::operator-(Rational<T,U> const &obj)
{
    if (denom == obj.denom)
    {
        return Rational(numer - obj.numer, denom);
    }
    else {
        return Rational(numer * obj.denom - denom * obj.numer,
                        denom * obj.denom);
    }
}
#+END_SRC

**** Tests
#+NAME: test-rational-sub
#+BEGIN_SRC C++
Rational<int,int> rat_sub_a = Rational<int,int>(1,4);
Rational<int,int> rat_sub_b = Rational<int,int>(2,4);
Rational<int,int> rat_sub_r1 = rat_sub_b - rat_sub_a;
assert(rat_sub_r1.numer == 1 && rat_sub_r1.denom == 4);
Rational<int,int> rat_sub_c = Rational<int,int>(5,7);
Rational<int,int> rat_sub_r2 = rat_sub_a - rat_sub_c;
rat_sub_r2.simplify();
assert(rat_sub_r2.numer == 13 && rat_sub_r2.denom == -28);
#+END_SRC
*** Library
#+BEGIN_SRC C++ :noweb yes :tangle rational.h :main no
template <typename T, typename U>
class Rational {
    public:
        T numer;
        U denom;
        Rational(T n, U d);
        T get_numerator(void);
        U get_denominator(void);
        void rescale_denom(U newval);
        void simplify(void);
        Rational operator+(Rational const &obj);
        Rational operator-(Rational const &obj);
        Rational operator*(Rational const &obj);
        Rational operator/(Rational const &obj);
};

template<typename T, typename U>
Rational<T, U>::Rational(T n, U d)
{
    this->numer = n;
    this->denom = d;
}

template<typename T, typename U>
T Rational<T,U>::get_numerator(void)
{
    return this->numer;
}

template<typename T, typename U>
U Rational<T,U>::get_denominator(void)
{
    return this->denom;
}

<<rational-rescale>>
<<gcd>>
<<rational-simp>>
<<rational-add>>
<<rational-sub>>
<<rational-mult>>
<<rational-div>>
#+END_SRC

#+RESULTS:

*** Tests
#+BEGIN_SRC C++ :noweb yes :tangle testrational.cpp
#include "rational.h"
#include <iostream>
#include <cassert>

int main()
{
    <<test-rational-simp>>
    <<test-rational-rescale>>
    <<test-rational-add>>
    <<test-rational-sub>>
    return 0;
}
#+END_SRC
** 2D Vector operations
*** Vector addition/subtraction

\( (x_1, y_1) \pm (x_2, y_2) = (x_1 \pm x_2, y_1 \pm y_2) \)

#+NAME: vector-add
#+BEGIN_SRC C++
template <typename T>
Vec<T> Vec<T>::add(Vec<T> a)
{
    Vec<T> res(this.dim);
    for (int i = 0; i < this->dim; ++i)
    {
        res->ary[i] = this->ary[i] + a.ary[i];
    }
}
#+END_SRC

#+NAME: vector-sub
#+BEGIN_SRC C++
template <typename T>
Vec<T> Vec<T>::sub(Vec<T> a)
{
    Vec<T> res(this->dim);
    for (int i = 0; i < this->dim; ++i)
    {
        res.ary[i] = this->ary[i] - a.ary[i];
    }
}
#+END_SRC

*** Vector norm/magnitude
\( |(x_1, y_1)| = \sqrt{ x_1^2 + y_1^2 }\)

Note:
To minimise floating point operations:
Simply use \( |(x_1, y_1)|^2 = x_1^2 + y_1^2 \) when possible. If
you need the exact length, you can take
the square root at the end.

#+NAME: vector-l2-sq
#+BEGIN_SRC C++
template<typename T>
T Vec<T>::l2_sq(void)
{
    T sq_sum;
    for (int i = 0; i < this->dim; ++i)
    {
        sq_sum += this->ary[i] * this->ary[i];
    }
    return sq_sum;
}
#+END_SRC

#+RESULTS: vector-l2-sq

*** Vector dot product
The dot product between \( \mathbf{x} \) and \( \mathbf{y}\):
\( \mathbf{x}^\intercal \mathbf{y} = \sum_{i=1}^n \mathbf{x}_i \mathbf{y}_i \)

#+NAME: vector-dot
#+BEGIN_SRC C++
template<typename T>
T Vec<T>::dot(Vec a)
{
    T sq_sum;
    for (int i = 0; i < this->dim; ++i)
    {
        sq_sum += this->ary[i] * a.ary[i];
    }
    return sq_sum;
}
#+END_SRC

#+RESULTS: vector-dot

*** Vector cross product
The cross product between \( \mathbf{x} \) and \( \mathbf{y} \)

#+NAME: vector-crs
#+BEGIN_SRC C++
template <typename T>
Vec<T> Vec<T>::crs_3d(Vec<T> a)
{
    Vec<T> res = Vec(3);
    res.ary[0] = this->ary[1] * a.ary[2] - this->ary[2] * a.ary[1];
    res.ary[1] = this->ary[2] * a.ary[0] - this->ary[0] * a.ary[2];
    res.ary[2] = this->ary[0] * a.ary[1] - this->ary[1] * a.ary[0];

    return res;
}
#+END_SRC


*** Line segment intersection

*** Library
#+BEGIN_SRC C++ :tangle compgeom.h :main no
template <typename T>
class Vec {
    public:
        T* ary;
        int dim;

        Vec(T arr[], int s);
        Vec(int s);
        Vec add(Vec a);
        Vec sub(Vec a);
        T l2_sq(void); // squared L2 norm
        T dot(Vec a); // dot product
        Vec crs_3d(Vec a); // true cross product of two vectors in 3-space
};
#+END_SRC

#+BEGIN_SRC C++ :noweb yes :tangle compgeom.cpp :main no
#include "compgeom.h"
template<typename T>
Vec<T>::Vec(T arr[], int s)
{
    this->ary = new T[s];
    this->dim = s;
    for (int i=0; i < s; i++)
    {
        this->ary[i] = arr[i];
    }
}

template<typename T>
Vec<T>::Vec(int s)
{
    this->ary = new T[s];
    this->dim = s;
}

<<vector-add>>
<<vector-sub>>
<<vector-l2-sq>>
<<vector-dot>>
<<vector-crs>>
#+END_SRC

#+BEGIN_SRC C++ :tangle testing.cpp
#include "compgeom.h"
#include <iostream>
int main()
{
    float a_elems[3] = { 1.0, 3.5, 1.5 };
    float b_elems[3] = { -0.5, 1.5, 1.5 };

    Vec<float> a = Vec<float>(a_elems, 3);
    Vec<float> b = Vec<float>(b_elems, 3);

    Vec<float> x = a.crs_3d(b);

    for (int i = 0; i < 3; i++)
        {
            std::cout << x.ary[i] << " ";
        }

    std::cout << "\n" << x.l2_sq() << "\n";

    return 0;
}
#+END_SRC
